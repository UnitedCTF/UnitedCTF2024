# GoQuick

## Write-up

En visitant le challenge, on peut voir qu'il y a une page `/maintenance.php`. Malheureusement on ne peut pas la consulter.<br>
En regardant dans le code, on peut voir que l'addresse IP de source doit Ãªtre `127.0.0.1`, soit l'IP loopback du serveur.

```php
<?php
if($_SERVER['REMOTE_ADDR'] != '127.0.0.1') {
    echo 'L\'accÃ¨s Ã  cette page est restreinte Ã  l\'administrateur local!';
    die();
}

echo $_ENV['FLAG']; // ğŸ‘€
?>
```

*Heureusement* pour nous, le site offre une fonctionnalitÃ© de notifications via webhook qui nous permet de faire des requÃªtes en tant que le serveur (un beau SSRF), Ã§a pourrait nous permettre de satisfaire la condition pour visiter `/maintenance.php`.

Cependant, en essayant des URLs tels que `http://127.0.0.1/maintenance.php` ou encore `http://localhost/`, on obtient une erreur obscure:

> Vous essayer d'accomplir quoi au juste? ğŸ¤¨

Si on regarde dans le code (dans le fichier `jobs.php`), on peut voir qu'il y a une validation pour vÃ©rifier qu'on n'envoie pas un URL avec l'IP `127.0.0.1`. Similairement, si on envoie un nom de domaine, une requÃªte DNS est envoyÃ©e (avec `dig`) pour vÃ©rifier que ce domaine ne rÃ©sout pas Ã  `127.0.0.1`.

```php
if(preg_match("/^" . IP_REGEX . "$/", $matches[1])) {
    if($matches[1] == "127.0.0.1") {
        $job["state"] = "error";
        $job["result"] = "Vous essayer d'accomplir quoi au juste? ğŸ¤¨";
        goto save;
    }
} else {
    $output = array();
    // premiÃ¨re requÃªte DNS ici
    exec("dig +short A " . escapeshellarg($matches[1]), $output);
    if(count($output) == 0) {
        // ...
    } else if($output[0] == "127.0.0.1") {
        $job["state"] = "error";
        $job["result"] = "Vous essayer d'accomplir quoi au juste? ğŸ¤¨";
        goto save;
    }
}

$output = array();
// deuxiÃ¨me requÃªte DNS ici
exec("curl -sS4gd @data/rides.json -m 1 --max-redirs 0 --proto =http,https " . escapeshellarg($url), $output);
```

Puisque deux requÃªtes DNS sont faites, soit une avec `dig` et une au moment de la requÃªte avec `curl`, on peut contourner la restriction avec du round-robin DNS.

En effet, on peut crÃ©er un nom de domaine avec deux entrÃ©es `A`, une qui pointe vers un IP alÃ©atoire comme `1.1.1.1` et une qui pointe vers `127.0.0.1`. Avec le round-robin (offert par la plupart des registraires/serveurs DNS), une fois de temps en temps, la premiÃ¨re requÃªte obtiendra `1.1.1.1` comme rÃ©ponse et la deuxiÃ¨me obtiendra `127.0.0.1`.

![entrÃ©es dns](dns_entries.png)

AprÃ¨s, on n'a qu'Ã  envoyer l'URL `http://<domaine>/maintenance.php` et avec un peu de chance, on reÃ§oit le flag via l'erreur.

![success](success.png)

## Flag
`flag-C3tteL1gn3DAtt3nt3EstR1d1cul3m3n7L0ngu3`